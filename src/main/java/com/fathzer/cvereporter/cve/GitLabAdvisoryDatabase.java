package com.fathzer.cvereporter.cve;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UncheckedIOException;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URI;
import java.net.URL;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fathzer.cvereporter.common.Artifact;
import com.fathzer.cvereporter.common.VersionRange;
import com.fathzer.cvereporter.utils.SafeTmpFiles;
import com.fathzer.cvereporter.utils.TinyRestClient;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;
import us.springett.cvss.Cvss;
import us.springett.cvss.Score;

public class GitLabAdvisoryDatabase extends DataBase {
	public static final URL SOURCE;
	
	private static final ObjectMapper MAPPER = new ObjectMapper(new YAMLFactory());
		
	@NoArgsConstructor
	@Getter
	@ToString
	@JsonIgnoreProperties(ignoreUnknown = true)
	private static class GitLabAdvisoryCVE {
		private String identifier;
		private String description;
		@JsonProperty("affected_range")
		private String range;
		private List<String> urls;
		@JsonProperty("cvss_v2")
		private String cvssV2;
		@JsonProperty("cvss_v3")
		private String cvssV3;
		@JsonProperty("fixed_versions")
		private List<String> fixedVersions;

		@JsonIgnore
		private Score getScore() {
			final String cvss; 
			if (cvssV3!= null) {
				cvss = cvssV3;
			} else if (cvssV2!=null) {
				cvss = cvssV2;
			} else {
				return null;
			}
			return Cvss.fromVector(cvss).calculateScore();
		}
	}
	
	static {
		try {
			SOURCE = URI.create("https://gitlab.com/api/v4/projects/gitlab-org%2Fadvisories-community/repository/archive.zip").toURL();
		} catch (MalformedURLException e) {
			throw new UncheckedIOException(e);
		}		
	}
	
	private final FileSystem fs;
	private final Path rootPath;
	
	public GitLabAdvisoryDatabase(File file) throws IOException {
		URI uri = URI.create("jar:"+file.toURI());
		this.fs = FileSystems.newFileSystem(uri, Collections.emptyMap());
		final Path zipTop = fs.getRootDirectories().iterator().next();
		try (Stream<Path> paths = Files.find(zipTop, 2, (p,a) -> a.isDirectory() && "maven".equals(fixedFileName(p)))) {
			final Optional<Path> first = paths.findFirst();
			if (first.isPresent()) {
				this.rootPath = first.get();
			} else {
				throw new IOException(String.format("Unable to find maven directory in %s file",file));
			}
		}
	}
	
	/** Gets the fixed fileName of a Path in a zip File System.
	 * <br>At least in Java 8 on Linux, the file name is followed by a / and the root directory has a null fileName.
	 * @param path The path
	 * @return Its file name (null if file does not exists)
	 */
	private String fixedFileName(Path path) {
		final Path fileName = path.getFileName();
		if (fileName==null) {
			return null;
		}
		String result = fileName.toString();
		if (result.charAt(result.length()-1)=='/') {
			result = result.substring(0, result.length()-1);
		}
		return result;
	}

	public GitLabAdvisoryDatabase(InputStream stream) throws IOException {
		this(toFile(stream));
	}

	public static GitLabAdvisoryDatabase fromURI(Proxy proxy, URL url) throws IOException {
		return new TinyRestClient().request(proxy, url, in -> {
			try {
				return new GitLabAdvisoryDatabase(in);
			} catch (IOException e) {
				throw new UncheckedIOException(e);
			}
		});
	}

	private static File toFile(InputStream stream) throws IOException {
		final File result = SafeTmpFiles.createTempFile("GitLabAdvisoryDB", ".bin");
		Files.copy(stream, result.toPath(), StandardCopyOption.REPLACE_EXISTING);
		return result;
	}

	private List<CVE> getCves(Artifact artifact) {
		final Path path = rootPath.resolve(artifact.getGroup()).resolve(artifact.getId());
		if (!Files.isDirectory(path)) {
			return Collections.emptyList();
		}
		try (Stream<Path> x = Files.walk(path, 1)) {
			return x.filter(Files::isRegularFile).map(p -> read(artifact, p)).collect(Collectors.toList());
		} catch (IOException e) {
			throw new UncheckedIOException(e);
		}
	}
	
	protected CVE read(Artifact id, Path path) {
		try (InputStream stream = Files.newInputStream(path)) {
			final GitLabAdvisoryCVE readValue = MAPPER.readValue(stream, GitLabAdvisoryCVE.class);
			final VersionRange range = getRange(id, readValue);
			final CVE result = new CVE(readValue.getIdentifier(), id, range, readValue.getDescription());
			final Score score = readValue.getScore();
			if (score!=null) {
				result.setScore(score.getBaseScore());
			}
			if (readValue.getUrls()!=null) {
				result.setReferences(readValue.getUrls());
			}
			if (readValue.getFixedVersions()!=null) {
				result.setFixedVersions(readValue.getFixedVersions());
			}
			return result;
		} catch (IOException e) {
			throw new UncheckedIOException(e);
		}
	}

	protected VersionRange getRange(final Artifact id, final GitLabAdvisoryCVE readValue) {
		try {
			return new VersionRange(readValue.getRange());
		} catch (IllegalArgumentException e) {
			throw new IllegalArgumentException("Unable to parse range on "+readValue.getIdentifier()+" CVE about artifact "+id,e);
		}
	}
	
	@Override
	protected List<CVE> getCVEList(Artifact artifact) {
		final List<CVE> content = cves.computeIfAbsent(artifact, this::getCves);
		return content.isEmpty()?null:content;
	}

	@Override
	public void close() throws IOException {
		this.fs.close();
	}
}
