package com.fathzer.cvereporter.rest;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UncheckedIOException;
import java.net.HttpURLConnection;
import java.net.Proxy;
import java.net.URL;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import lombok.AllArgsConstructor;
import lombok.Getter;

public class TinyRestClient {
	
	private static final String BEARER = "Bearer ";

	/** An exception that indicates a problem as occured while requesting an URL.
	 */
	@AllArgsConstructor
	@Getter
	public static class FailureException extends IOException {
		private static final long serialVersionUID = 1L;
		private final int responseCode;
		private final transient Supplier<InputStream> errorStream;
		@Override
		public String getMessage() {
			try {
				try (InputStream in = getErrorStream().get()) {
					return getResponseCode() + "-" + new BufferedReader(new InputStreamReader(in))
							   .lines().collect(Collectors.joining("\n"));
				}
			} catch (IOException ex) {
				throw new UncheckedIOException(ex);
			}
		}
	}

	/** Performs a GET request on an URL.
	 * @param <T> The type of the result of the web service call.
	 * @param proxy The The proxy to use to connect to the service.
	 * @param url The web service URL. It should contains all the required query parameters.
	 * @param token an authentication token to send in "Authorization" header (ignored if null).
	 * @param success A function that will convert the web service response stream to a <b>T</b> instance (Typically based on a jackson objet mapper call to readValue).
	 * @param preprocessor A consumer that will customize the HttpURLConnection that will be used to perform the request. It can, for instance, set the connection time out, add more headers, etc...
	 * 	Pass null if you need no customization.
	 * @return A T instance
	 * @throws FailureException if the server did not return a 200 http code.
	 * @throws IOException If something went wrong (server is unreachable, etc ...).
	 */
	public <T> T request(Proxy proxy, URL url, String token, Function<Supplier<InputStream>, T> success, Consumer<HttpURLConnection> preprocessor) throws IOException {
        final HttpURLConnection connection = (HttpURLConnection) url.openConnection(proxy);
        try {
        	if (token!=null) {
        		addHeader(connection,"Authorization", token.startsWith(BEARER) ? token : BEARER+token);
        	}
			if (preprocessor!=null) {
				preprocessor.accept(connection);
			}
	        final int responseCode = connection.getResponseCode();
			if (responseCode==HttpURLConnection.HTTP_OK) {
		        return success.apply(new StreamSupplier(connection));
			} else {
				try (InputStream in = connection.getErrorStream()) {
					// We should copy the stream because the finally clause will close the connection before the exception add a chance to being caught
					throw new FailureException(responseCode, new CopyStreamSupplier(connection.getErrorStream()));
				}
			}
		} finally {
        	connection.disconnect();
        }
	}
	
	/** Adds a header to an existing connection.
	 * <br>If the header already exists, its value is replaced. To add multiple values for the same header, use a comma separated list.
	 * @param connection The connection.
	 * @param name The header name
	 * @param value The header value.
	 */
	public void addHeader(HttpURLConnection connection, String name, String value) {
		connection.setRequestProperty(name, value);
	}
	
	@AllArgsConstructor
	private static class StreamSupplier implements Supplier<InputStream> {
		private final HttpURLConnection connection;
		@Override
		public InputStream get() {
			try {
				return connection.getInputStream();
			} catch (IOException e) {
				throw new UncheckedIOException(e);
			}
		}
	}
	
	private static class CopyStreamSupplier implements Supplier<InputStream> {
		private final byte[] response;
		
		private CopyStreamSupplier(InputStream in) throws IOException {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			byte[] buffer = new byte[1024];
			while (true) {
			    int r = in.read(buffer);
			    if (r == -1) break;
			    out.write(buffer, 0, r);
			}
			response = out.toByteArray();
		}
		
		@Override
		public InputStream get() {
			return new ByteArrayInputStream(response);
		}
	}
}
