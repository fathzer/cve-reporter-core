package com.fathzer.cvereporter.common;

import java.util.Collection;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.maven.artifact.versioning.InvalidVersionSpecificationException;
import org.apache.maven.artifact.versioning.Restriction;

/** A Version range.
 */
public class VersionRange {
	private final org.apache.maven.artifact.versioning.VersionRange internal;
	
	/** Constructor.
	 * @param range A String that denotes a range in Maven style format:
	 * Some spec examples are:
	 * <ul>
	 * <li><code>1.0</code> or <code>[1.0]</code> Version 1.0</li>
	 * <li><code>[1.0,2.0)</code> Versions 1.0 (included) to 2.0 (not included)</li>
	 * <li><code>[1.0,2.0]</code> Versions 1.0 to 2.0 (both included)</li>
	 * <li><code>[1.5,)</code> Versions 1.5 and higher</li>
	 * <li><code>(,1.0],[1.2,)</code> Versions up to 1.0 (included) and 1.2 or higher</li>
	 * </ul>
	 * Please note that contrary to the Maven specification, the ranges are not necessarily ordered here.
	 */
	public VersionRange(String range) {
		org.apache.maven.artifact.versioning.VersionRange vs;
		try {
			vs = org.apache.maven.artifact.versioning.VersionRange.createFromVersionSpec(range);
		} catch (InvalidVersionSpecificationException e) {
			vs = tryByParts(range);
		}
		this.internal = vs;
	}

	protected org.apache.maven.artifact.versioning.VersionRange tryByParts(String range) {
		final Comparator<? super Restriction> comparator = (o1,o2) -> o1.getLowerBound().compareTo(o2.getLowerBound());
		range = splitRanges(range).stream().flatMap(r -> new VersionRange(r).internal.getRestrictions().stream()).sorted(comparator).map(Object::toString).collect(Collectors.joining(","));
		try {
			return org.apache.maven.artifact.versioning.VersionRange.createFromVersionSpec(range);
		} catch (InvalidVersionSpecificationException e) {
			throw new IllegalArgumentException(e);
		}
	}
	
	/** Tests whether a version is included in this range. 
	 * @param version The version to test
	 * @return true if it is included
	 */
	public boolean contains(Version version) {
		return internal.containsVersion(version.getInternal());
	}
	
	private Collection<String> splitRanges(String ranges) {
		List<String> result = new LinkedList<>();
		int offset = 0;
		boolean inRange = false;
		for (int i=0; i<ranges.length(); i++) {
			final char c = ranges.charAt(i);
			if (c==',' && !inRange) {
				result.add(ranges.substring(offset,i).trim());
				offset = i+1;
			} else if (inRange && (c==']' || c==')')) {
				inRange = false;
			} else if (!inRange && (c=='[' || c=='(')) {
				inRange = true;
			}
		}
		if (offset!=ranges.length()-1) {
			result.add(ranges.substring(offset,ranges.length()).trim());
		}
		return result;
	}
}