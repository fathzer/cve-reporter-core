package com.fathzer.cvereporter.builder;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.maven.model.Model;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.codehaus.plexus.util.xml.pull.XmlPullParserException;

import com.fathzer.cvereporter.common.Project;
import com.fathzer.cvereporter.common.Version;
import com.fathzer.cvereporter.common.Artifact;
import com.fathzer.cvereporter.common.Dependency;
import com.fathzer.cvereporter.repository.CodeRepository;
import com.fathzer.cvereporter.utils.SafeTmpFiles;

import lombok.AllArgsConstructor;
import lombok.Getter;

public class MavenEngine implements BuildEngine {
	public static final String POM_XML = "pom.xml";
	protected static final String DEPENDENCY_FILE = "dependencies.txt";
	private static final String MAVEN_CMD;
	
	@AllArgsConstructor
	@Getter
	private static class PomConfig {
		BuildStatus status;
		Map<File,String> pathToPom;
	}
	
	private final CodeRepository codeRepo;
	private final Map<Thread, File> workingDirs;
	private Map<String,String> environmentVariables;
	
	static {
		MAVEN_CMD = System.getProperty("os.name").toLowerCase().startsWith("win") ? "mvn.cmd" : "mvn";
	}
	
	public MavenEngine(CodeRepository codeRepo) {
		this.codeRepo = codeRepo;
		this.workingDirs = new ConcurrentHashMap<>();
		this.environmentVariables = null;
	}
	
	/** Sets the environment variables used to execute the mvn command.
	 * <br>This method is particularly useful to set the JAVA_HOME environment variable if its default value is not suitable
	 * @param environment a map of environment variable names to their values.
	 */
	public void setEnvironmentVariables(Map<String,String> environment) {
		this.environmentVariables = environment;
	}
	
	private File getWorkingDir() {
		return workingDirs.computeIfAbsent(Thread.currentThread(), t -> {
			try {
				return SafeTmpFiles.createTempDirectory("mvnEngineTmpDir");
			} catch (IOException e) {
				throw new UncheckedIOException(e);
			}
		});
	}

	@Override
	public DependencySet getDependencies(Project project) throws IOException {
		final PomConfig config = getPoms(project);
		if (!BuildStatus.OK.equals(config.getStatus())) {
			return new DependencySet(config.getStatus(), null);
		}
		if (generate(config)!=0) {
			return new DependencySet(BuildStatus.BUILD_ERROR, null);
		} else {
			return new DependencySet(BuildStatus.OK, parse(getPaths(config)));
		}
	}
	
	private Collection<Path> getPaths(PomConfig config) {
		return config.pathToPom.keySet().stream().map(f -> f.toPath().getParent().resolve(DEPENDENCY_FILE)).collect(Collectors.toList());
	}
	
	protected Set<Dependency> parse(Collection<Path> paths) throws IOException {
		Stream<Dependency> dependencies = Stream.empty();
		for (Path f : paths) {
			dependencies = Stream.concat(dependencies, getDependencies(f).stream());
		}
		return dependencies.collect(Collectors.toSet());
	}
	
	private Collection<Dependency> getDependencies(Path f) throws IOException {
		try (Stream<String> lines = Files.lines(f)) {
			return lines.map(this::toDependency).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
		}
	}

	private PomConfig getPoms(Project project) throws IOException {
		try {
			final String pom = codeRepo.getFile(project, POM_XML);
			return getPoms(project, pom);
		} catch (FileNotFoundException | NoSuchFileException e) {
			return new PomConfig(BuildStatus.NOT_THIS_BUILDER, null);
		}
	}
	
	private PomConfig getPoms(Project project, String pom) throws IOException {
		final Map<File,String> fileToPom = new TreeMap<>();
		try (Reader reader = new StringReader(pom)) {
			Model model = new MavenXpp3Reader().read(reader);
			List<String> modules = model.getModules();
			for (String module : modules) {
				final String path = module+"/"+POM_XML;
				fileToPom.put(new File(getWorkingDir(), path), codeRepo.getFile(project, path));
			}
		} catch (XmlPullParserException | IOException e) {
			return new PomConfig(BuildStatus.BUILD_ERROR,null);
		}
		fileToPom.put(new File(getWorkingDir(), POM_XML), pom);
		return new PomConfig(BuildStatus.OK, fileToPom);
	}
	
	private int generate(PomConfig config) throws IOException {
		for (Entry<File, String> pom : config.pathToPom.entrySet()) {
			pom.getKey().getParentFile().mkdirs();
			try (BufferedWriter writer= new BufferedWriter(new FileWriter(pom.getKey()))) {
				writer.write(pom.getValue());
			}
		}
		final File workingDir = getWorkingDir();
		return getDependenciesFile(workingDir);
	}

	/** Gets the dependencies file that contains all the dependencies of a Maven project in the same format as the one created by the command <code>mvn dependency:list</code>
	 * @param projectDir The project directory (pom.xml should be at this directory's root).
	 * @return 0 if the build succeed, another int if it failed
	 * @throws IOException If something went wrong while reading the pom files.
	 */
	protected int getDependenciesFile(final File projectDir) throws IOException {
		final ProcessBuilder pb = new ProcessBuilder(Arrays.asList(MAVEN_CMD,"-q","-DoutputFile="+DEPENDENCY_FILE,"dependency:list"));
		if (environmentVariables!=null) {
			pb.environment().putAll(environmentVariables);
		}
		pb.directory(projectDir);
		pb.redirectError(new File(projectDir,"errors.log"));
		pb.redirectOutput(new File(projectDir,"out.log"));
		Process p = pb.start();
		try {
			return p.waitFor();
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
			return -1;
		}
	}
	
	private Optional<Dependency> toDependency(String line) {
		if (!line.startsWith("   ") || "none".equals(line.trim())) {
			return Optional.empty();
		}
		String[] keys = line.split(":");
		return Optional.of(new Dependency(new Artifact(keys[0].trim(), keys[1].trim()), new Version(keys[3].trim())));
	}
}
