package com.fathzer.cvereporter;

import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.fathzer.cvereporter.builder.BuildEngine;
import com.fathzer.cvereporter.builder.BuildStatus;
import com.fathzer.cvereporter.builder.DependencySet;
import com.fathzer.cvereporter.common.Dependency;
import com.fathzer.cvereporter.common.Project;
import com.fathzer.cvereporter.repository.CodeRepository;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class CVEReporter {
	private CodeRepository codeRepo;
	private BuildEngine buildEngine;
	private Function<Collection<Dependency>, List<Alert>> cveDB;
	private Predicate<Project> projectFilter;
	private boolean ignoreTestDependencies;
	private boolean quiet;
	private Semaphore semaphore;
	private boolean hasError;

	public CVEReporter(CodeRepository codeRepo, BuildEngine buildEngine, Function<Collection<Dependency>, List<Alert>> cveDB) {
		this.codeRepo = codeRepo;
		this.buildEngine = buildEngine;
		this.cveDB = cveDB;
		this.semaphore = new Semaphore(1);
	}

	public void setProjectFilter(Predicate<Project> projectFilter) {
		this.projectFilter = projectFilter;
	}
	
	public void setIgnoreTestDependencies(boolean ignore) {
		this.ignoreTestDependencies = ignore;
	}

	/** Sets the quiet mode of this reporter.
	 * <br>By default, this class logs some information in the slf4j log.
	 * Setting quiet mode to true deactivate this behavior (the errors are always logged).   
	 * @param quiet true to deactivate information logging
	 */
	public void setQuiet(boolean quiet) {
		this.quiet = quiet;
	}
	
	public void setParallel(int maxConcurrentThread) {
		this.semaphore = new Semaphore(maxConcurrentThread);
	}

	public List<ProjectCVEReport> getReports() throws IOException {
		this.hasError = false;
		if (!quiet) {
			log.info("Getting list of projects from code repository");
		}
		List<Project> projects = codeRepo.getProjects();
		if (projectFilter!=null) {
			projects = projects.stream().filter(projectFilter).collect(Collectors.toList());
		}
		if (!quiet) {
			log.info("Found {} projects", projects.size());
		}

		final AtomicInteger count = new AtomicInteger();
		if (!quiet) {
			final Timer timer = new Timer(true);
			timer.schedule(new TimerTask() {
				@Override
				public void run() {
					log.info("{} projects are processed", count);
				}
			}, 10000, 10000);
		}
		final long start = System.currentTimeMillis();
		final Stream<Project> stream = projects.parallelStream();
		final List<ProjectCVEReport> result = stream.map(project -> {
		    this.semaphore.acquireUninterruptibly();
		    try {
				final Optional<ProjectCVEReport> report = getReport(project);
				count.incrementAndGet();
				return report;
		    } finally {
		    	this.semaphore.release();
		    }
		}).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
		if (!quiet) {
			log.info("Projects processed in {}s",(System.currentTimeMillis()-start)/1000);
		}
		return result;

	}
	
	public boolean hasError() {
		return hasError;
	}

	private Optional<ProjectCVEReport> getReport(Project project) {
		try {
			final DependencySet dependencies = buildEngine.getDependencies(project);
			final BuildStatus status = dependencies.getStatus();
			final List<Alert> alerts = BuildStatus.OK.equals(status) ? cveDB.apply(getFiltered(dependencies.getDependencies())) : Collections.emptyList();
			return Optional.of(new ProjectCVEReport(project, status, alerts));
		} catch (Exception e) {
			log.error("An error occured while processing "+project.getPath(),e);
			this.hasError = true;
			return Optional.empty();
		}
	}
	
	private Set<Dependency> getFiltered(Set<Dependency> dependencies) {
		if (ignoreTestDependencies) {
			dependencies = dependencies.stream().filter(d -> !d.isTestCode()).collect(Collectors.toSet());
		}
		return dependencies;
	}
}
