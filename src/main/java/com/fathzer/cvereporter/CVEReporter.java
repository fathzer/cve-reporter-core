package com.fathzer.cvereporter;

import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.fathzer.cvereporter.builder.BuildEngine;
import com.fathzer.cvereporter.builder.BuildStatus;
import com.fathzer.cvereporter.builder.DependencySet;
import com.fathzer.cvereporter.common.Dependency;
import com.fathzer.cvereporter.repository.CodeRepository;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class CVEReporter {
	private CodeRepository codeRepo;
	private BuildEngine buildEngine;
	private Function<Collection<Dependency>, List<Alert>> cveDB;
	private Semaphore semaphore;

	public CVEReporter(CodeRepository codeRepo, BuildEngine buildEngine, Function<Collection<Dependency>, List<Alert>> cveDB) {
		this.codeRepo = codeRepo;
		this.buildEngine = buildEngine;
		this.cveDB = cveDB;
		this.semaphore = new Semaphore(1);
	}

	public void setParallel(int maxConcurrentThread) {
		this.semaphore = new Semaphore(maxConcurrentThread);
	}

	public List<ProjectCVEReport> getReports() throws IOException {
		log.info("Getting list of projects from code repository");
		final List<Project> projects = codeRepo.getProjects();
		log.info("Found {} projects", projects.size());

		final Timer timer = new Timer(true);
		final AtomicInteger count = new AtomicInteger();  
		timer.schedule(new TimerTask() {
			@Override
			public void run() {
				log.info("{} projects are processed", count);
			}
		}, 10000, 10000);
		final Stream<Project> stream = projects.parallelStream();
		return stream.map(project -> {
		    this.semaphore.acquireUninterruptibly();
		    try {
				final ProjectCVEReport report = getReport(project);
				count.incrementAndGet();
				return report;
		    } finally {
		    	this.semaphore.release();
		    }
		}).collect(Collectors.toList());
	}

	protected ProjectCVEReport getReport(Project project) {
		try {
			final DependencySet dependencies = buildEngine.getDependencies(project);
			final BuildStatus status = dependencies.getStatus();
			final List<Alert> alerts = BuildStatus.OK.equals(status) ? cveDB.apply(dependencies.getDependencies()) : Collections.emptyList();
			return new ProjectCVEReport(project, status, alerts);
		} catch (Exception e) {
			log.error("An error occured while processing "+project.getPath(),e);
			return new ProjectCVEReport(project, e);
		}
	}
}
